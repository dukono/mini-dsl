package dukono.minidsl.processor.generator;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import dukono.minidsl.processor.DslContext;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import java.io.IOException;

/**
 * Generates the Api factory class for a DSL domain. This class now contains all
 * nested inner classes for the DSL.
 * 
 * Example generated code:
 * 
 * <pre>
 * public final class OrderApi {
 * 	private OrderApi() {
 * 	}
 * 
 * 	public static AnchorActions from() {
 * 		return new AnchorActions();
 * 	}
 * 
 * 	// All nested classes: Fields, Operations, AnchorOperations, etc.
 * }
 * </pre>
 */
public class ApiGenerator {

	public void generate(final DslContext context, final Filer filer) throws IOException {
		final String className = context.getApiClassName();

		// Always use AnchorActions (since all classes are generated)
		final String anchorClass = GeneratedClassNames.ANCHOR_ACTIONS.getClassName();

		final ClassName anchorClassName = ClassName.get(context.getPackageName(), className, anchorClass);

		final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(className)
				.addModifiers(Modifier.PUBLIC, Modifier.FINAL)
				.addJavadoc("Generated Api factory class for $L domain.\n", context.getDomainName()).addJavadoc("\n")
				.addJavadoc("Contains all nested DSL classes: Fields, Anchors, and factory methods.\n").addJavadoc("\n")
				.addJavadoc("Example:\n").addJavadoc("<pre>\n").addJavadoc("$L.from()\n", className)
				.addJavadoc("    .field(f -> f.FIELD_NAME).equalTo(value)\n").addJavadoc("    .other();\n")
				.addJavadoc("</pre>\n").addJavadoc("\n").addJavadoc("@generated by DslProcessor\n");

		// Private constructor
		final MethodSpec constructor = MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE)
				.addJavadoc("Private constructor to prevent instantiation.\n").build();
		classBuilder.addMethod(constructor);

		// Generate all nested inner classes
		classBuilder.addType(new FieldsGenerator().generateAsNestedClass(context));
		// Operations class NOT generated - operators are used directly as string
		// literals

		// Only generate DTO if it's not provided by the user
		if (context.shouldGenerateDto()) {
			classBuilder.addType(new DtoGenerator().generateAsNestedClass(context));
		}

		classBuilder.addType(new AnchorOperationsGenerator().generateAsNestedClass(context));
		classBuilder.addType(new AnchorOperationsLogicalGenerator().generateAsNestedClass(context));
		classBuilder.addType(new AnchorOperationsOneGenerator().generateAsNestedClass(context));
		classBuilder.addType(new AnchorOneGenerator().generateAsNestedClass(context));
		classBuilder.addType(new AnchorListGenerator().generateAsNestedClass(context));
		classBuilder.addType(new AnchorLogicalMainGenerator().generateAsNestedClass(context));
		classBuilder.addType(new AnchorMainGenerator().generateAsNestedClass(context));
		classBuilder.addType(new AnchorActionsGenerator().generateAsNestedClass(context));

		// from() method
		final MethodSpec fromMethod = MethodSpec.methodBuilder("from").addModifiers(Modifier.PUBLIC, Modifier.STATIC)
				.returns(anchorClassName).addStatement("return new $L()", anchorClass)
				.addJavadoc("Creates a new DSL instance.\n").addJavadoc("\n")
				.addJavadoc("@return a new $L instance\n", anchorClass).build();
		classBuilder.addMethod(fromMethod);

		// from(dto) method
		final MethodSpec fromDtoMethod = MethodSpec.methodBuilder("from").addModifiers(Modifier.PUBLIC, Modifier.STATIC)
				.returns(anchorClassName).addParameter(context.getDtoClassName(), "dto")
				.addStatement("return new $L(dto)", anchorClass)
				.addJavadoc("Creates a new DSL instance with an existing DTO.\n").addJavadoc("\n")
				.addJavadoc("@param dto the DTO to use\n").addJavadoc("@return a new $L instance\n", anchorClass)
				.build();
		classBuilder.addMethod(fromDtoMethod);

		// from(Collection<String>) method - always generated since Actions is always
		// included
		final MethodSpec fromCollectionMethod = MethodSpec.methodBuilder("from")
				.addModifiers(Modifier.PUBLIC, Modifier.STATIC).returns(anchorClassName)
				.addParameter(ParameterizedTypeName.get(ClassName.get(java.util.Collection.class),
						ClassName.get(String.class)), "queries")
				.addStatement("return new $L(queries)", anchorClass)
				.addJavadoc("Creates a new DSL instance with predefined queries.\n").addJavadoc("\n")
				.addJavadoc("@param queries the collection of queries to parse\n")
				.addJavadoc("@return a new $L instance\n", anchorClass).build();
		classBuilder.addMethod(fromCollectionMethod);

		final TypeSpec typeSpec = classBuilder.build();

		final JavaFile javaFile = JavaFile.builder(context.getPackageName(), typeSpec)
				.addFileComment("Generated by Mini-DSL Processor")
				.addFileComment("\nDO NOT EDIT - This file is auto-generated").build();

		javaFile.writeTo(filer);
	}
}

package dukono.minidsl.processor.generator;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;
import com.squareup.javapoet.WildcardTypeName;
import dukono.minidsl.annotation.DslOperation;
import dukono.minidsl.processor.DslContext;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.util.Collection;

/**
 * Generates the AnchorOperationsBase class for a DSL domain.
 * 
 * Example generated code:
 * 
 * <pre>
 * public class VehicleAnchorOperations<H extends AnchorHolderMain<?, ?, H, ?>> extends AnchorOperationsBasic<H> {
 * 
 * 	public H equalTo(Object arg) {
 * 		return this.create(Query.from(this.getName(), "eq", arg));
 * 	}
 * }
 * </pre>
 */
public class AnchorOperationsGenerator {

	public void generate(final DslContext context, final Filer filer) throws IOException {
		final TypeSpec typeSpec = this.generateAsNestedClass(context);

		final JavaFile javaFile = JavaFile.builder(context.getPackageName(), typeSpec)
				.addFileComment("Generated by Mini-DSL Processor")
				.addFileComment("\nDO NOT EDIT - This file is auto-generated").build();

		javaFile.writeTo(filer);
	}

	public TypeSpec generateAsNestedClass(final DslContext context) {
		final String className = GeneratedClassNames.ANCHOR_OPERATIONS.getClassName();

		// Type variable H
		final TypeVariableName h = TypeVariableName.get("H",
				ParameterizedTypeName.get(ClassName.get(dukono.minidsl.AnchorHolderMain.class),
						WildcardTypeName.subtypeOf(Object.class), WildcardTypeName.subtypeOf(Object.class),
						TypeVariableName.get("H"), WildcardTypeName.subtypeOf(Object.class)));

		final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(className)
				.addModifiers(Modifier.PUBLIC, Modifier.STATIC).addTypeVariable(h)
				.superclass(ParameterizedTypeName.get(ClassName.get(dukono.minidsl.AnchorOperationsBasic.class),
						TypeVariableName.get("H")))
				.addJavadoc("Generated AnchorOperations class for $L domain.\n", context.getDomainName())
				.addJavadoc("\n").addJavadoc("Contains all operation methods that can be called on fields.\n")
				.addJavadoc("\n").addJavadoc("@generated by DslProcessor\n");

		// Add method for each operation
		for (final DslOperation operation : context.getOperations()) {
			final MethodSpec method = this.generateOperationMethod(operation);
			classBuilder.addMethod(method);

			// For list operations, also generate an overloaded method with delimiter and
			// brackets parameters
			if (operation.type() == dukono.minidsl.annotation.OperationType.WITH_LIST
					|| operation.type() == dukono.minidsl.annotation.OperationType.NO_OP_WITH_LIST) {
				final MethodSpec overloadedMethod = this.generateListOperationWithCustomFormatting(operation);
				classBuilder.addMethod(overloadedMethod);
			}
		}

		return classBuilder.build();
	}

	private MethodSpec generateOperationMethod(final DslOperation operation) {
		final String methodName = operation.name();

		final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName).addModifiers(Modifier.PUBLIC)
				.returns(TypeVariableName.get("H"));

		if (!operation.description().isEmpty()) {
			methodBuilder.addJavadoc("$L\n", operation.description());
		}

		switch (operation.type()) {
			case WITH_ARG -> {
				// Operation with pattern: getName + operation + arg
				// Example: equalTo(Object arg)
				methodBuilder.addParameter(Object.class, "arg");
				methodBuilder.addStatement("return this.create($T.from(this.getName(), $S, arg))",
						ClassName.get(dukono.minidsl.Query.class), operation.operator());
			}
			case NO_OP_WITH_ARG -> {
				// Operation with pattern: getName + null + arg
				// Example: noOpVals(Object arg)
				methodBuilder.addParameter(Object.class, "arg");
				methodBuilder.addStatement("return this.create($T.from(this.getName(), null, arg))",
						ClassName.get(dukono.minidsl.Query.class));
			}
			case WITH_LIST -> {
				// Operation with pattern: getName + operation + list
				// Example: inValues(Collection<Object> arg)
				methodBuilder.addParameter(ParameterizedTypeName.get(ClassName.get(Collection.class),
						WildcardTypeName.subtypeOf(Object.class)), "arg");
				methodBuilder.addStatement(
						"return this.create($T.from(this.getName(), $S, this.listFormatting(arg, $S, $S)))",
						ClassName.get(dukono.minidsl.Query.class), operation.operator(), operation.listDelimiter(),
						operation.listBrackets());
			}
			case NO_OP_WITH_LIST -> {
				// Operation with pattern: getName + null + list
				// Example: noOpList(Collection<Object> arg)
				methodBuilder.addParameter(ParameterizedTypeName.get(ClassName.get(Collection.class),
						WildcardTypeName.subtypeOf(Object.class)), "arg");
				methodBuilder.addStatement(
						"return this.create($T.from(this.getName(), null, this.listFormatting(arg, $S, $S)))",
						ClassName.get(dukono.minidsl.Query.class), operation.listDelimiter(), operation.listBrackets());
			}
			case NO_VALUE ->
				// Operation with pattern: getName + operation + empty
				// Example: isNotNull()
				methodBuilder.addStatement("return this.create($T.from(this.getName(), $S, $T.empty()))",
						ClassName.get(dukono.minidsl.Query.class), operation.operator(),
						ClassName.get(java.util.Optional.class));
			case NO_OP_NO_VALUE ->
				// Operation with pattern: getName + null + empty
				// No operator and no value
				// Example: include()
				methodBuilder.addStatement("return this.create($T.from(this.getName(), null, $T.empty()))",
						ClassName.get(dukono.minidsl.Query.class), ClassName.get(java.util.Optional.class));
		}

		return methodBuilder.build();
	}

	private MethodSpec generateListOperationWithCustomFormatting(final DslOperation operation) {
		final String methodName = operation.name();

		final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName).addModifiers(Modifier.PUBLIC)
				.returns(TypeVariableName.get("H"));

		if (!operation.description().isEmpty()) {
			methodBuilder.addJavadoc("$L\n", operation.description());
		}
		methodBuilder.addJavadoc("@param arg the collection of values\n");
		methodBuilder.addJavadoc("@param delimiter custom delimiter for list formatting\n");
		methodBuilder.addJavadoc("@param brackets custom brackets for list wrapping\n");

		// Add parameters: collection, delimiter, brackets
		methodBuilder.addParameter(
				ParameterizedTypeName.get(ClassName.get(Collection.class), WildcardTypeName.subtypeOf(Object.class)),
				"arg");
		methodBuilder.addParameter(String.class, "delimiter");
		methodBuilder.addParameter(String.class, "brackets");

		// Generate the method body based on operation type
		if (operation.type() == dukono.minidsl.annotation.OperationType.WITH_LIST) {
			methodBuilder.addStatement(
					"return this.create($T.from(this.getName(), $S, this.listFormatting(arg, delimiter, brackets)))",
					ClassName.get(dukono.minidsl.Query.class), operation.operator());
		} else if (operation.type() == dukono.minidsl.annotation.OperationType.NO_OP_WITH_LIST) {
			methodBuilder.addStatement(
					"return this.create($T.from(this.getName(), null, this.listFormatting(arg, delimiter, brackets)))",
					ClassName.get(dukono.minidsl.Query.class));
		}

		return methodBuilder.build();
	}
}

package dukono.minidsl.processor.generator;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;
import com.squareup.javapoet.WildcardTypeName;
import dukono.minidsl.annotation.DslOperation;
import dukono.minidsl.processor.DslContext;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.util.Collection;
import java.util.function.Function;

/**
 * Generates the AnchorOperationsOne class for a DSL domain. Used for operations
 * on individual items within lists.
 */
public class AnchorOperationsOneGenerator {

	public void generate(final DslContext context, final Filer filer) throws IOException {
		final TypeSpec typeSpec = this.generateAsNestedClass(context);

		final JavaFile javaFile = JavaFile.builder(context.getPackageName(), typeSpec)
				.addFileComment("Generated by Mini-DSL Processor")
				.addFileComment("\nDO NOT EDIT - This file is auto-generated").build();

		javaFile.writeTo(filer);
	}

	public TypeSpec generateAsNestedClass(final DslContext context) {
		final String className = GeneratedClassNames.ANCHOR_OPERATIONS_ONE.getClassName();
		final String logicalClassName = "AnchorOperationsLogical";

		// Type variables
		final TypeVariableName h = TypeVariableName.get("H",
				ParameterizedTypeName.get(ClassName.get(dukono.minidsl.AnchorHolderOne.class),
						WildcardTypeName.subtypeOf(Object.class), WildcardTypeName.subtypeOf(Object.class),
						TypeVariableName.get("H"), TypeVariableName.get("O"),
						WildcardTypeName.subtypeOf(Object.class)));
		final TypeVariableName o = TypeVariableName.get("O");

		final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(className)
				.addModifiers(Modifier.PUBLIC, Modifier.STATIC).addTypeVariable(h).addTypeVariable(o)
				.superclass(ParameterizedTypeName.get(ClassName.bestGuess(logicalClassName), TypeVariableName.get("H")))
				.addAnnotation(
						AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", "unchecked").build())
				.addJavadoc("Generated AnchorOperationsOne class for $L domain.\n", context.getDomainName())
				.addJavadoc("Operations for individual items within lists using Function extractors.\n")
				.addJavadoc("\n@generated by DslProcessor\n");

		// Generate methods for each operation defined in context
		for (final DslOperation operation : context.getOperations()) {
			final MethodSpec method = this.generateOperationMethod(operation);
			classBuilder.addMethod(method);

			// For list operations, also generate an overloaded method with delimiter and
			// brackets parameters
			if (operation.type() == dukono.minidsl.annotation.OperationType.WITH_LIST
					|| operation.type() == dukono.minidsl.annotation.OperationType.NO_OP_WITH_LIST) {
				final MethodSpec overloadedMethod = this.generateListOperationWithCustomFormatting(operation);
				classBuilder.addMethod(overloadedMethod);
			}
		}

		return classBuilder.build();
	}

	private MethodSpec generateOperationMethod(final DslOperation operation) {
		final String methodName = operation.name();

		final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName).addModifiers(Modifier.PUBLIC)
				.returns(TypeVariableName.get("H"));

		if (!operation.description().isEmpty()) {
			methodBuilder.addJavadoc("$L\n", operation.description());
		}

		switch (operation.type()) {
			case WITH_ARG -> {
				// Operation with single value: Function<O, Object>
				methodBuilder.addParameter(ParameterizedTypeName.get(ClassName.get(Function.class),
						TypeVariableName.get("O"), ClassName.get(Object.class)), "extractor");
				methodBuilder.addStatement(
						"return this.create($T.from(this.getName(), $S, extractor.apply(this.holder.getItemUnit())))",
						ClassName.get(dukono.minidsl.Query.class), operation.operator());
			}
			case NO_OP_WITH_ARG -> {
				// Operation with single value but no operator: Function<O, Object>
				methodBuilder.addParameter(ParameterizedTypeName.get(ClassName.get(Function.class),
						TypeVariableName.get("O"), ClassName.get(Object.class)), "extractor");
				methodBuilder.addStatement(
						"return this.create($T.from(this.getName(), null, extractor.apply(this.holder.getItemUnit())))",
						ClassName.get(dukono.minidsl.Query.class));
			}
			case WITH_LIST -> {
				// Operation with collection: Function<O, Collection<?>>
				methodBuilder.addParameter(ParameterizedTypeName.get(ClassName.get(Function.class),
						TypeVariableName.get("O"), ParameterizedTypeName.get(ClassName.get(Collection.class),
								WildcardTypeName.subtypeOf(Object.class))),
						"extractor");
				methodBuilder.addStatement(
						"return this.create($T.from(this.getName(), $S, this.listFormatting(extractor.apply(this.holder.getItemUnit()), $S, $S)))",
						ClassName.get(dukono.minidsl.Query.class), operation.operator(), operation.listDelimiter(),
						operation.listBrackets());
			}
			case NO_OP_WITH_LIST -> {
				// Operation with collection but no operator: Function<O, Collection<?>>
				methodBuilder.addParameter(ParameterizedTypeName.get(ClassName.get(Function.class),
						TypeVariableName.get("O"), ParameterizedTypeName.get(ClassName.get(Collection.class),
								WildcardTypeName.subtypeOf(Object.class))),
						"extractor");
				methodBuilder.addStatement(
						"return this.create($T.from(this.getName(), null, this.listFormatting(extractor.apply(this.holder.getItemUnit()), $S, $S)))",
						ClassName.get(dukono.minidsl.Query.class), operation.listDelimiter(), operation.listBrackets());
			}
			case NO_VALUE ->
				// Operation without parameters
				methodBuilder.addStatement("return this.create($T.from(this.getName(), $S, $T.empty()))",
						ClassName.get(dukono.minidsl.Query.class), operation.operator(),
						ClassName.get(java.util.Optional.class));
			case NO_OP_NO_VALUE ->
				// Operation that just adds the field name
				// No operator and no value
				methodBuilder.addStatement("return this.create($T.from(this.getName(), null, $T.empty()))",
						ClassName.get(dukono.minidsl.Query.class), ClassName.get(java.util.Optional.class));
		}

		return methodBuilder.build();
	}

	private MethodSpec generateListOperationWithCustomFormatting(final DslOperation operation) {
		final String methodName = operation.name();

		final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName).addModifiers(Modifier.PUBLIC)
				.returns(TypeVariableName.get("H"));

		if (!operation.description().isEmpty()) {
			methodBuilder.addJavadoc("$L\n", operation.description());
		}
		methodBuilder.addJavadoc("@param extractor function to extract collection from item\n");
		methodBuilder.addJavadoc("@param delimiter custom delimiter for list formatting\n");
		methodBuilder.addJavadoc("@param brackets custom brackets for list wrapping\n");

		// Add parameters: extractor, delimiter, brackets
		methodBuilder.addParameter(ParameterizedTypeName.get(ClassName.get(Function.class), TypeVariableName.get("O"),
				ParameterizedTypeName.get(ClassName.get(Collection.class), WildcardTypeName.subtypeOf(Object.class))),
				"extractor");
		methodBuilder.addParameter(String.class, "delimiter");
		methodBuilder.addParameter(String.class, "brackets");

		// Generate the method body based on operation type
		if (operation.type() == dukono.minidsl.annotation.OperationType.WITH_LIST) {
			methodBuilder.addStatement(
					"return this.create($T.from(this.getName(), $S, this.listFormatting(extractor.apply(this.holder.getItemUnit()), delimiter, brackets)))",
					ClassName.get(dukono.minidsl.Query.class), operation.operator());
		} else if (operation.type() == dukono.minidsl.annotation.OperationType.NO_OP_WITH_LIST) {
			methodBuilder.addStatement(
					"return this.create($T.from(this.getName(), null, this.listFormatting(extractor.apply(this.holder.getItemUnit()), delimiter, brackets)))",
					ClassName.get(dukono.minidsl.Query.class));
		}

		return methodBuilder.build();
	}
}

package dukono.minidsl.processor.generator;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;
import dukono.minidsl.processor.DslContext;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.function.Function;
import java.util.function.UnaryOperator;

/**
 * Generates the AnchorActions class for a DSL domain. Provides action
 * operations like replace, modify, and remove.
 */
public class AnchorActionsGenerator {

	public void generate(final DslContext context, final Filer filer) throws IOException {
		final TypeSpec typeSpec = this.generateAsNestedClass(context);

		final JavaFile javaFile = JavaFile.builder(context.getPackageName(), typeSpec)
				.addFileComment("Generated by Mini-DSL Processor")
				.addFileComment("\nDO NOT EDIT - This file is auto-generated").build();

		javaFile.writeTo(filer);
	}

	public TypeSpec generateAsNestedClass(final DslContext context) {
		final String className = GeneratedClassNames.ANCHOR_ACTIONS.getClassName();
		final String fieldsClassName = GeneratedClassNames.FIELDS.getClassName();
		final String operationsLogicalClassName = GeneratedClassNames.ANCHOR_OPERATIONS_LOGICAL.getClassName();
		final String anchorOneClassName = GeneratedClassNames.ANCHOR_ONE.getClassName();
		final String anchorListClassName = GeneratedClassNames.ANCHOR_LIST.getClassName();

		final String anchorLogicalMainClassName = GeneratedClassNames.ANCHOR_LOGICAL_MAIN.getClassName();
		final ClassName dtoClassName = context.getDtoClassName();

		final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(className)
				.addModifiers(Modifier.PUBLIC, Modifier.STATIC)
				.superclass(ParameterizedTypeName.get(ClassName.get(dukono.minidsl.AnchorHolderMainActions.class),
						ClassName.bestGuess(fieldsClassName), dtoClassName, ClassName.bestGuess(className),
						ParameterizedTypeName.get(ClassName.bestGuess(operationsLogicalClassName),
								ClassName.bestGuess(className))))
				.addAnnotation(
						AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", "unchecked").build())
				.addJavadoc("Generated AnchorActions class for $L domain.\n", context.getDomainName())
				.addJavadoc("Provides action operations like replace, modify, and remove.\n")
				.addJavadoc("\n@generated by DslProcessor\n");

		// Default constructor
		final MethodSpec constructor = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
				.addStatement("super(new $T<$T>() {}, new $T<$L<?>>() {}, new $T<$L<$L>>() {}, new $L())",
						ClassName.get(com.google.common.reflect.TypeToken.class), dtoClassName,
						ClassName.get(com.google.common.reflect.TypeToken.class), anchorListClassName,
						ClassName.get(com.google.common.reflect.TypeToken.class), operationsLogicalClassName, className,
						fieldsClassName)
				.build();

		// Constructor with DTO
		final MethodSpec constructorWithDto = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
				.addParameter(dtoClassName, "dto").addStatement("this()")
				.addStatement("this.dtoClazzInstance = java.util.Optional.ofNullable(dto)").build();

		// Constructor with collection
		final MethodSpec constructorWithCollection = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
				.addParameter(ParameterizedTypeName.get(ClassName.get(Collection.class), ClassName.get(String.class)),
						"dtoData")
				.addStatement("this()").addStatement("this.getDto().parseFilters(dtoData, $T.class, $T.class)",
						context.getOperationsEnumClassName(), ClassName.bestGuess(fieldsClassName))
				.build();

		// listCollapseAnd method
		final TypeVariableName l = TypeVariableName.get("L");
		final MethodSpec listCollapseAnd = MethodSpec.methodBuilder("listCollapseAnd").addModifiers(Modifier.PUBLIC)
				.addTypeVariable(l).returns(ClassName.bestGuess(className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(List.class), l), "list")
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ParameterizedTypeName.get(ClassName.bestGuess(anchorOneClassName), l)), "operator")
				.addStatement("return super.collapse(list, operator, $T.AND)",
						ClassName.get(dukono.minidsl.Query.class))
				.build();

		// listCollapseOr method
		final MethodSpec listCollapseOr = MethodSpec.methodBuilder("listCollapseOr").addModifiers(Modifier.PUBLIC)
				.addTypeVariable(l).returns(ClassName.bestGuess(className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(List.class), l), "list")
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ParameterizedTypeName.get(ClassName.bestGuess(anchorOneClassName), l)), "operator")
				.addStatement("return super.collapse(list, operator, $T.OR)", ClassName.get(dukono.minidsl.Query.class))
				.build();

		// listAddForEach method
		final MethodSpec listAddForEach = MethodSpec.methodBuilder("listAddForEach").addModifiers(Modifier.PUBLIC)
				.addTypeVariable(l).returns(ClassName.bestGuess(className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(List.class), l), "list")
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ParameterizedTypeName.get(ClassName.bestGuess(anchorOneClassName), l)), "operator")
				.addStatement("return super.notCollapse(list, operator)").build();

		// replace method
		final MethodSpec replace = MethodSpec.methodBuilder("replace").addModifiers(Modifier.PUBLIC)
				.returns(ClassName.bestGuess(className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ClassName.bestGuess(anchorLogicalMainClassName)), "toFind")
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ClassName.bestGuess(anchorLogicalMainClassName)), "newValue")
				.addStatement("return super.replace(toFind, newValue, new $T<$L>() {})",
						ClassName.get(com.google.common.reflect.TypeToken.class), anchorLogicalMainClassName)
				.build();

		// modify method
		final MethodSpec modify = MethodSpec.methodBuilder("modify").addModifiers(Modifier.PUBLIC)
				.returns(ClassName.bestGuess(className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ClassName.bestGuess(anchorLogicalMainClassName)), "change")
				.addParameter(ParameterizedTypeName.get(ClassName.get(Function.class),
						ClassName.get(dukono.minidsl.Comparator.class),
						ClassName.get(dukono.minidsl.ComparatorEnum.class)), "comparatorFunction")
				.addStatement("return super.modify(change, comparatorFunction, new $T<$L>() {})",
						ClassName.get(com.google.common.reflect.TypeToken.class), anchorLogicalMainClassName)
				.build();

		// remove method
		final MethodSpec remove = MethodSpec.methodBuilder("remove").addModifiers(Modifier.PUBLIC)
				.returns(ClassName.bestGuess(className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(Function.class),
						ParameterizedTypeName.get(ClassName.get(dukono.minidsl.RemoveBy.class),
								ClassName.bestGuess(anchorLogicalMainClassName)),
						ClassName.get(dukono.minidsl.RemoveBy.Remover.class)), "removeFunction")
				.addStatement("return super.remove(removeFunction, new $T<$L>() {})",
						ClassName.get(com.google.common.reflect.TypeToken.class), anchorLogicalMainClassName)
				.build();

		classBuilder.addMethod(constructor);
		classBuilder.addMethod(constructorWithDto);
		classBuilder.addMethod(constructorWithCollection);
		classBuilder.addMethod(listCollapseAnd);
		classBuilder.addMethod(listCollapseOr);
		classBuilder.addMethod(listAddForEach);
		classBuilder.addMethod(replace);
		classBuilder.addMethod(modify);
		classBuilder.addMethod(remove);

		return classBuilder.build();
	}
}

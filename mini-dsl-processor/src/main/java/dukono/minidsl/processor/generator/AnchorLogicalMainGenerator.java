package dukono.minidsl.processor.generator;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;
import dukono.minidsl.processor.DslContext;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.util.List;
import java.util.function.UnaryOperator;

/**
 * Generates the AnchorLogicalMain class for a DSL domain. Main anchor with
 * logical operations support.
 */
public class AnchorLogicalMainGenerator {

	public void generate(final DslContext context, final Filer filer) throws IOException {
		final String className = context.getDomainName() + GeneratedClassNames.ANCHOR_LOGICAL_MAIN.getClassName();
		final String fieldsClassName = context.getFieldsClassName();
		final String operationsLogicalClassName = context.getDomainName()
				+ GeneratedClassNames.ANCHOR_OPERATIONS_LOGICAL.getClassName();
		final String anchorOneClassName = context.getDomainName() + GeneratedClassNames.ANCHOR_ONE.getClassName();
		final String anchorListClassName = context.getDomainName() + GeneratedClassNames.ANCHOR_LIST.getClassName();
		final String dtoClassName = context.getDtoClass();

		final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(className).addModifiers(Modifier.PUBLIC)
				.superclass(ParameterizedTypeName.get(ClassName.get(dukono.minidsl.AnchorHolderMainLogical.class),
						ClassName.get(context.getPackageName(), fieldsClassName), ClassName.bestGuess(dtoClassName),
						ClassName.get(context.getPackageName(), className),
						ParameterizedTypeName.get(ClassName.get(context.getPackageName(), operationsLogicalClassName),
								ClassName.get(context.getPackageName(), className))))
				.addAnnotation(
						AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", "unchecked").build())
				.addJavadoc("Generated AnchorLogicalMain class for $L domain.\n", context.getDomainName())
				.addJavadoc("Main anchor with logical operations support.\n")
				.addJavadoc("\n@generated by DslProcessor\n");

		// Constructor
		final MethodSpec constructor = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
				.addStatement("super(new $T<$T>() {}, new $T<$T<?>>() {}, new $T<$L<$T>>() {}, new $T())",
						ClassName.get(com.google.common.reflect.TypeToken.class), ClassName.bestGuess(dtoClassName),
						ClassName.get(com.google.common.reflect.TypeToken.class),
						ClassName.get(context.getPackageName(), anchorListClassName),
						ClassName.get(com.google.common.reflect.TypeToken.class), operationsLogicalClassName,
						ClassName.get(context.getPackageName(), className),
						ClassName.get(context.getPackageName(), fieldsClassName))
				.build();

		// listCollapseAnd method
		final TypeVariableName l = TypeVariableName.get("L");
		final MethodSpec listCollapseAnd = MethodSpec.methodBuilder("listCollapseAnd").addModifiers(Modifier.PUBLIC)
				.addTypeVariable(l).returns(ClassName.get(context.getPackageName(), className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(List.class), l), "list")
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ParameterizedTypeName.get(ClassName.get(context.getPackageName(), anchorOneClassName), l)),
						"operator")
				.addJavadoc("Collapses list items with AND logic.\n").addJavadoc("@param <L> list item type\n")
				.addJavadoc("@param list the list to process\n")
				.addJavadoc("@param operator the operator to apply to each item\n")
				.addJavadoc("@return this anchor for chaining\n")
				.addStatement("return super.collapse(list, operator, $T.AND)",
						ClassName.get(dukono.minidsl.Query.class))
				.build();

		// listCollapseOr method
		final MethodSpec listCollapseOr = MethodSpec.methodBuilder("listCollapseOr").addModifiers(Modifier.PUBLIC)
				.addTypeVariable(l).returns(ClassName.get(context.getPackageName(), className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(List.class), l), "list")
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ParameterizedTypeName.get(ClassName.get(context.getPackageName(), anchorOneClassName), l)),
						"operator")
				.addJavadoc("Collapses list items with OR logic.\n").addJavadoc("@param <L> list item type\n")
				.addJavadoc("@param list the list to process\n")
				.addJavadoc("@param operator the operator to apply to each item\n")
				.addJavadoc("@return this anchor for chaining\n")
				.addStatement("return super.collapse(list, operator, $T.OR)", ClassName.get(dukono.minidsl.Query.class))
				.build();

		// listAddForEach method
		final MethodSpec listAddForEach = MethodSpec.methodBuilder("listAddForEach").addModifiers(Modifier.PUBLIC)
				.addTypeVariable(l).returns(ClassName.get(context.getPackageName(), className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(List.class), l), "list")
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ParameterizedTypeName.get(ClassName.get(context.getPackageName(), anchorOneClassName), l)),
						"operator")
				.addJavadoc("Adds each list item individually without collapsing.\n")
				.addJavadoc("@param <L> list item type\n").addJavadoc("@param list the list to process\n")
				.addJavadoc("@param operator the operator to apply to each item\n")
				.addJavadoc("@return this anchor for chaining\n")
				.addStatement("return super.notCollapse(list, operator)").build();

		classBuilder.addMethod(constructor);
		classBuilder.addMethod(listCollapseAnd);
		classBuilder.addMethod(listCollapseOr);
		classBuilder.addMethod(listAddForEach);

		final TypeSpec typeSpec = classBuilder.build();

		final JavaFile javaFile = JavaFile.builder(context.getPackageName(), typeSpec)
				.addFileComment("Generated by Mini-DSL Processor")
				.addFileComment("\nDO NOT EDIT - This file is auto-generated").build();

		javaFile.writeTo(filer);
	}

	public TypeSpec generateAsNestedClass(final DslContext context) {
		final String className = GeneratedClassNames.ANCHOR_LOGICAL_MAIN.getClassName();
		final String fieldsClassName = GeneratedClassNames.FIELDS.getClassName();
		final String operationsLogicalClassName = GeneratedClassNames.ANCHOR_OPERATIONS_LOGICAL.getClassName();
		final String anchorOneClassName = GeneratedClassNames.ANCHOR_ONE.getClassName();
		final String anchorListClassName = GeneratedClassNames.ANCHOR_LIST.getClassName();
		final ClassName dtoClassName = context.getDtoClassName();

		final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(className)
				.addModifiers(Modifier.PUBLIC, Modifier.STATIC)
				.superclass(ParameterizedTypeName.get(ClassName.get(dukono.minidsl.AnchorHolderMainLogical.class),
						ClassName.bestGuess(fieldsClassName), dtoClassName, ClassName.bestGuess(className),
						ParameterizedTypeName.get(ClassName.bestGuess(operationsLogicalClassName),
								ClassName.bestGuess(className))))
				.addAnnotation(
						AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", "unchecked").build())
				.addJavadoc("Generated AnchorLogicalMain class for $L domain.\n", context.getDomainName())
				.addJavadoc("Main anchor with logical operations support.\n")
				.addJavadoc("\n@generated by DslProcessor\n");

		// Constructor
		final MethodSpec constructor = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
				.addStatement("super(new $T<$L>() {}, new $T<$L<?>>() {}, new $T<$L<$L>>() {}, new $L())",
						ClassName.get(com.google.common.reflect.TypeToken.class), dtoClassName,
						ClassName.get(com.google.common.reflect.TypeToken.class), anchorListClassName,
						ClassName.get(com.google.common.reflect.TypeToken.class), operationsLogicalClassName, className,
						fieldsClassName)
				.build();

		// listCollapseAnd method
		final TypeVariableName l = TypeVariableName.get("L");
		final MethodSpec listCollapseAnd = MethodSpec.methodBuilder("listCollapseAnd").addModifiers(Modifier.PUBLIC)
				.addTypeVariable(l).returns(ClassName.bestGuess(className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(List.class), l), "list")
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ParameterizedTypeName.get(ClassName.bestGuess(anchorOneClassName), l)), "operator")
				.addJavadoc("Collapses list items with AND logic.\n").addJavadoc("@param <L> list item type\n")
				.addJavadoc("@param list the list to process\n")
				.addJavadoc("@param operator the operator to apply to each item\n")
				.addJavadoc("@return this anchor for chaining\n")
				.addStatement("return super.collapse(list, operator, $T.AND)",
						ClassName.get(dukono.minidsl.Query.class))
				.build();

		// listCollapseOr method
		final MethodSpec listCollapseOr = MethodSpec.methodBuilder("listCollapseOr").addModifiers(Modifier.PUBLIC)
				.addTypeVariable(l).returns(ClassName.bestGuess(className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(List.class), l), "list")
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ParameterizedTypeName.get(ClassName.bestGuess(anchorOneClassName), l)), "operator")
				.addJavadoc("Collapses list items with OR logic.\n").addJavadoc("@param <L> list item type\n")
				.addJavadoc("@param list the list to process\n")
				.addJavadoc("@param operator the operator to apply to each item\n")
				.addJavadoc("@return this anchor for chaining\n")
				.addStatement("return super.collapse(list, operator, $T.OR)", ClassName.get(dukono.minidsl.Query.class))
				.build();

		// listAddForEach method
		final MethodSpec listAddForEach = MethodSpec.methodBuilder("listAddForEach").addModifiers(Modifier.PUBLIC)
				.addTypeVariable(l).returns(ClassName.bestGuess(className))
				.addParameter(ParameterizedTypeName.get(ClassName.get(List.class), l), "list")
				.addParameter(ParameterizedTypeName.get(ClassName.get(UnaryOperator.class),
						ParameterizedTypeName.get(ClassName.bestGuess(anchorOneClassName), l)), "operator")
				.addJavadoc("Adds each list item individually without collapsing.\n")
				.addJavadoc("@param <L> list item type\n").addJavadoc("@param list the list to process\n")
				.addJavadoc("@param operator the operator to apply to each item\n")
				.addJavadoc("@return this anchor for chaining\n")
				.addStatement("return super.notCollapse(list, operator)").build();

		classBuilder.addMethod(constructor);
		classBuilder.addMethod(listCollapseAnd);
		classBuilder.addMethod(listCollapseOr);
		classBuilder.addMethod(listAddForEach);

		return classBuilder.build();
	}
}
